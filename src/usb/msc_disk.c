#include "../modules/status_indicator/status_indicator.h"
#include "bsp/board_api.h"
#include "debug_cdc.h"
#include "tusb.h"

#if CFG_TUD_MSC

// whether host does safe-eject
static bool ejected = false;
static bool disk_ejected_flag = false;
static uint32_t disk_change_counter = 0;

// ADDED: Variable to track MSC activity
static volatile bool msc_busy = false;
static volatile uint32_t last_activity_time = 0;

// Some MCU doesn't have enough 8KB SRAM to store the whole disk
// We will use Flash as read-only disk with board that has
// CFG_EXAMPLE_MSC_READONLY defined

#define README_CONTENTS                                                                                                \
    "This is tinyusb's MassStorage Class demo.\r\n\r\n\
If you find any bugs or get any questions, feel free to file an\r\n\
issue at github.com/hathach/tinyusb"

enum {
    DISK_BLOCK_NUM = 16, // 8KB is the smallest size that windows allow to mount
    DISK_BLOCK_SIZE = 512
};

static
#ifdef CFG_EXAMPLE_MSC_READONLY
    const
#endif
    uint8_t msc_disk[DISK_BLOCK_NUM][DISK_BLOCK_SIZE] = {
        //------------- Block0: Boot Sector -------------//
        {0xEB, 0x3C, 0x90, 0x4D, 0x53, 0x44, 0x4F, 0x53, 0x35, 0x2E, 0x30, 0x00, 0x02, 0x01, 0x01, 0x00, 0x01, 0x10,
         0x00, 0x10, 0x00, 0xF8, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x80, 0x00, 0x29, 0x34, 0x12, 0x00, 0x00, 'T', 'i', 'n', 'y', 'U', 'S', 'B', ' ', 'M', 'S', 'C', 0x46, 0x41,
         0x54, 0x31, 0x32, 0x20, 0x20, 0x20, 0x00, 0x00,

         // Zero up to 2 last bytes of FAT magic code
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00,

         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00,

         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00,

         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAA},

        //------------- Block1: FAT12 Table -------------//
        {
            0xF8, 0xFF, 0xFF, 0xFF, 0x0F // first 2 entries must be F8FF, third
                                         // entry is cluster end of readme file
        },

        //------------- Block2: Root Directory -------------//
        {
            // first entry is volume label
            'T', 'i', 'n', 'y', 'U', 'S', 'B', ' ', 'M', 'S', 'C', 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x4F, 0x6D, 0x65, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            // second entry is readme file
            'R', 'E', 'A', 'D', 'M', 'E', ' ', ' ', 'T', 'X', 'T', 0x20, 0x00, 0xC6, 0x52, 0x6D, 0x65, 0x43, 0x65, 0x43,
            0x00, 0x00, 0x88, 0x6D, 0x65, 0x43, 0x02, 0x00, sizeof(README_CONTENTS) - 1, 0x00, 0x00,
            0x00 // readme's files size (4 Bytes)
        },

        //------------- Block3: Readme Content -------------//
        {README_CONTENTS}};

// Public function to check MSC activity
bool tud_msc_busy(void) {
    return msc_busy;
}

// Mark the start of an activity
static inline void msc_set_busy(void) {
    msc_busy = true;
    last_activity_time = get_absolute_time();
}

// Check for activity timeout
void tud_msc_check_idle(void) {
    if (msc_busy) {
        // if after 200ms of inactivity, mark as idle
        if (absolute_time_diff_us(last_activity_time, get_absolute_time()) > 200000) {
            msc_busy = false;
        }
    }
}

// Invoked when received SCSI_CMD_INQUIRY, v2 with full inquiry response
uint32_t tud_msc_inquiry2_cb(uint8_t lun, scsi_inquiry_resp_t *inquiry_resp, uint32_t bufsize) {
    (void) lun;
    (void) bufsize;
    const char vid[] = "TinyUSB";
    const char pid[] = "Mass Storage";
    const char rev[] = "1.0";

    (void) strncpy((char *) inquiry_resp->vendor_id, vid, 8);
    (void) strncpy((char *) inquiry_resp->product_id, pid, 16);
    (void) strncpy((char *) inquiry_resp->product_rev, rev, 4);

    return sizeof(scsi_inquiry_resp_t); // 36 bytes
}

#ifdef __cplusplus
extern "C" {
#endif

void tud_msc_inquiry_cb(uint8_t lun, uint8_t vendor_id[8], uint8_t product_id[16], uint8_t product_rev[4]) {
    (void) lun;

    memcpy(vendor_id, "SGLab   ", 8);
    memcpy(product_id, "FPV-SL USB Flash", 16);
    memcpy(product_rev, "1.0", 4);
}

#ifdef __cplusplus
}
#endif

// Invoked when received Test Unit Ready command.
bool tud_msc_test_unit_ready_cb(uint8_t lun) {
    (void) lun;

    // RAM disk is ready until ejected
    if (ejected) {
        // Additional Sense 3A-00 is NOT_FOUND
        return tud_msc_set_sense(lun, SCSI_SENSE_NOT_READY, 0x3a, 0x00);
    }

    // Force media changed right after write
    if (disk_ejected_flag) {
        disk_ejected_flag = false;
        debug_cdc("Signaling UNIT_ATTENTION (media changed)");
        // Code SCSI : Media Changed
        tud_msc_set_sense(lun, SCSI_SENSE_UNIT_ATTENTION, 0x28, 0x00);
        return false; // Pas prÃªt pour forcer un refresh
    }

    return true;
}

// Invoked when received SCSI_CMD_READ_CAPACITY_10 and
// SCSI_CMD_READ_FORMAT_CAPACITY to determine the disk size
void tud_msc_capacity_cb(uint8_t lun, uint32_t *block_count, uint16_t *block_size) {
    (void) lun;
    *block_count = DISK_BLOCK_NUM;
    *block_size = DISK_BLOCK_SIZE;
}

// Invoked when received Start Stop Unit command
bool tud_msc_start_stop_cb(uint8_t lun, uint8_t power_condition, bool start, bool load_eject) {
    (void) lun;
    (void) power_condition;

    if (load_eject) {
        if (start) {
            // load disk storage
        } else {
            // unload disk storage
            ejected = true;
        }
    }

    return true;
}

// Callback invoked when received READ10 command.
int32_t tud_msc_read10_cb(uint8_t lun, uint32_t lba, uint32_t offset, void *buffer, uint32_t bufsize) {
    (void) lun;

    // Mark as busy
    msc_set_busy();

    // out of ramdisk
    if (lba >= DISK_BLOCK_NUM) {
        return -1;
    }

    // Check for overflow of offset + bufsize
    if (lba * DISK_BLOCK_SIZE + offset + bufsize > DISK_BLOCK_NUM * DISK_BLOCK_SIZE) {
        return -1;
    }

    uint8_t const *addr = msc_disk[lba] + offset;
    (void) memcpy(buffer, addr, bufsize);

    char str_buffer[64];
    snprintf(str_buffer, sizeof(str_buffer), "READ10: Success, returned %lu bytes\r\n", bufsize);
    debug_cdc(str_buffer);
    return (int32_t) bufsize;
}

void tud_msc_write10_complete_cb(uint8_t lun) {
    (void) lun;
    msc_set_busy();
    disk_change_counter++;
    debug_cdc("Write complete, invalidating cache\r\n");
    // Mask disk has changed
    disk_ejected_flag = true;
}

bool tud_msc_is_writable_cb(uint8_t lun) {
    (void) lun;

#ifdef CFG_EXAMPLE_MSC_READONLY
    return false;
#else
    return true;
#endif
}

// MODIFIED: Callback invoked when received WRITE10 command.
int32_t tud_msc_write10_cb(uint8_t lun, uint32_t lba, uint32_t offset, uint8_t *buffer, uint32_t bufsize) {
    (void) lun;

    // Mark as busy
    msc_set_busy();

    // out of ramdisk
    if (lba >= DISK_BLOCK_NUM) {
        return -1;
    }

#ifndef CFG_EXAMPLE_MSC_READONLY
    uint8_t *addr = msc_disk[lba] + offset;
    (void) memcpy(addr, buffer, bufsize);
#else
    (void) lba;
    (void) offset;
    (void) buffer;
#endif

    return (int32_t) bufsize;
}

// Callback invoked when received an SCSI command not in built-in list below
int32_t tud_msc_scsi_cb(uint8_t lun, uint8_t const scsi_cmd[16], void *buffer, uint16_t bufsize) {
    (void) lun;
    (void) scsi_cmd;
    (void) buffer;
    (void) bufsize;

    // currently no other commands is supported

    // Set Sense = Invalid Command Operation
    (void) tud_msc_set_sense(lun, SCSI_SENSE_ILLEGAL_REQUEST, 0x20, 0x00);

    return -1; // stall/failed command request;
}

#endif
